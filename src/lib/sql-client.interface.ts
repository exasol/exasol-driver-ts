/*
 * File generated by Interface generator (dotup.dotup-vscode-interface-generator)
 * Date: 2022-04-14 07:21:51
 */
import { SQLQueriesResponse, SQLResponse } from './types';
import { CommandsNoResult, Attributes, Commands } from './commands';

export type Cancelable = () => void;

export type CetCancelFunction = (cancel?: Cancelable) => void;

export interface IExasolDriver {
  /**
   * Connect to database
   *
   * @async
   * @reject {Error}
   * @returns {Promise.<void>}
   */
  connect(): Promise<void>;
  /**
   * Cancel the last active job
   */
  cancel(): Promise<void>;
  /**
   *  Close current connection
   */
  close(): Promise<void>;
  /**
   * Execute single SQL statement
   *
   * @async
   * @param {string} sqlStatement
   * @param {Partial<Attributes>} attributes
   * @reject {Error}
   * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
   */
  execute(sqlStatement: string, attributes?: Partial<Attributes>, getCancel?: CetCancelFunction): Promise<SQLResponse<SQLQueriesResponse>>;
  /**
   * Executes multiple SQL statements sequentially as a batch.
   *
   * @async
   * @param {string[]} sqlStatements - Array of sql statements
   * @param {Partial<Attributes>} attributes
   * @reject {Error}
   * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
   */
  executeBatch(
    sqlStatements: string[],
    attributes?: Partial<Attributes>,
    getCancel?: CetCancelFunction
  ): Promise<SQLResponse<SQLQueriesResponse>>;
  /**
   * Prepare statement
   *
   * @async
   * @param  {string} sqlStatement
   * @reject {Error}
   * @returns {Promise.<IStatement>}
   */
  prepare(sqlStatement: string): Promise<IStatement>;
  /**
   * Send commands which have no results
   * @param {CommandsNoResult} cmd
   */
  sendCommandWithNoResult(cmd: CommandsNoResult): Promise<void>;
  /**
   * Send commands and wait for result, while a command is executed all other commands will be rejected till the current command finished.
   * @async
   * @param  {Commands} cmd
   * @reject {Error}
   * @template T
   * @returns {Promise.<SQLResponse<T>>}
   */
  sendCommand<T>(cmd: Commands): Promise<SQLResponse<T>>;
}

export interface IStatement {
  /**
   * Close statement
   */
  close(): Promise<void>;
  /**
   *  Execute prepared statement with given args
   *
   * @async
   * @param {...any} args
   * @reject {Error}
   * @returns {Promise.<SQLResponse<SQLQueriesResponse>>}
   */
  execute(...args: Array<unknown>): Promise<SQLResponse<SQLQueriesResponse>>;
}
